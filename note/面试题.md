## HTTP

1. 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

   答：在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。**所以默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。**

2. 一个 TCP 连接可以对应几个 HTTP 请求？

   了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

3. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

   HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。**在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。**

4. 为什么有的时候刷新页面不需要重新建立 SSL 连接？

   TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的

5. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

   有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。

6. HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？

   - 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
   - 和服务器建立多个 TCP 连接。
   - 服务端把文件进行合并一次性返回
   - 建多个DNS扩大TCP
   
   
## 并发问题
java中的状态与linux中的状态

1. synchronized的实现原理
2. synchronized在方法上但是同一个对象为何可以不互斥
3. thread.join的含义
4. thread.join的含义是当前线程需要等待previousThread线程终止之后才从thread.join返回。简单来说，就是线程没有执行完之前，主线程会一直阻塞在join方法处。有很多人不理解join为什么阻塞的是主线程呢? 不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个**方法的调用者是在主线程中的。所以造成主线程阻塞。**
- 线程是如何被阻塞的？又是通过什么方法唤醒的呢？
- 为什么previousThread线程执行完毕就能够唤醒住线程呢？或者说是在什么时候唤醒的？
4. Object.wait、notify的原理
wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。
wait前要先拿到锁。 此时的线程状态 是怎么样 挂起 还是 在linux中的状态又是怎样， notify后线程是怎么得到唤醒操作。

通过上述两段代码，可以看出线程的挂起和唤醒是通过UNIX(对应BSD版本)线程库函数pthread_cond_wait和pthread_cond_signal实现的。